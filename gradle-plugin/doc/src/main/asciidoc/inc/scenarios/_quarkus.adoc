[[quarkus-scenario]]
== Get started with Quarkus and Minikube
You can easily get started with using {plugin} on a https://quarkus.io/[Quarkus] without providing any explicit configuration. {plugin} would generate an opinionated container image and manifests by inspecting your project configuration.

This is an example of how you can use the JKube zero configuration for a Quarkus project.

[[quarkus-scenario-prerequisites]]
=== Prerequisites
You will need the following for the scenario:

* `minikube` installed and running on your computer
* `minikube` ingress addon enabled
+
[source,sh,subs="attributes+"]
----
$ minikube addons enable ingress
----
* Use the docker daemon installed in minikube
+
[source,sh,subs="attributes+"]
----
$ eval $(minikube -p minikube docker-env)
----


[[quarkus-scenario-zero-configuration]]
=== Zero configuration
1. Start by generating a new Gradle Quarkus project from https://code.quarkus.io. Make sure Gradle is selected. Download the generated project and extract the content.

2. Open the `build.gradle` file and add the plugin in the `plugins` section.
+
[source,groovy,subs="attributes+"]
----
plugins {
   id 'java'
   id 'io.quarkus'
   id 'org.eclipse.jkube.{pluginExtension}' version '{version}'
}
----
3. Run the command:
+
[source,sh,subs="attributes+"]
----
$ ./gradlew quarkusBuild k8sBuild k8sResource k8sApply
----

The task <<jkubePush>> is not required as we are using the Minikube internal container image registry.

At this point, the Quarkus app has been built, containerized, configured for kubernetes and deployed to the minikube cluster. But there is no external endpoint to access to it:

[source,sh,subs="attributes+"]
----
$ kubectl get svc
NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
kubernetes   ClusterIP   10.96.0.1      <none>        443/TCP    14h
quarkus      ClusterIP   10.101.31.90   <none>        8080/TCP   13h

$ kubectl get ingress
No resources found in default namespace.
----

[[quarkus-scenario-external-url]]
=== External URL
To make this service available publicly, change the settings in `gradle.properties`.

1. Retrieve the minikube ip address
+
[source,sh,subs="attributes+"]
----
$ minikube ip
192.168.99.102
----

2. Add the following in the `gradle.properties` file. For the domain, we are using `nip.io` service that dynamically maps custom hostname and IP address and avoid editing the `etc/hosts` file.
+
[source,properties,indent=0,subs="verbatim,quotes,attributes"]
----
# Enable Creating External Urls
jkube.createExternalUrls=true
# Configure host domain suffix for Ingress
jkube.domain=192.168.99.102.nip.io
----

3. Re-generate and apply the kubenetes resource
+
[source,sh,subs="attributes+"]
----
$ ./gradlew k8sResource k8sApply
----

4. Make sure the ingress resource has been created
+
[source,sh,subs="attributes+"]
----
$ kubectl get ingress
NAME      CLASS    HOSTS                           ADDRESS          PORTS   AGE
quarkus   <none>   quarkus.192.168.99.102.nip.io   192.168.99.102   80      30m
----

5. Give it a try:
+
[source,sh,subs="attributes+"]
----
$ curl http://quarkus.192.168.99.102.nip.io/hello
Hello RESTEasy
----

=== Quarkus native
To package the native executable in a container, simply set the quarkus property `quarkus.package.type` to `native`.

[source,sh,subs="attributes+"]
----
$ ./gradlew quarkusBuild k8sBuild k8sResource k8sApply -Dquarkus.package.type=native
----

This is it! Jkube detects the quarkus packaging type and generate a working image container with the Quarkus native executable.
